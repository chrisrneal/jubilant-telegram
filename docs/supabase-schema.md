# Supabase Database Schema for Text Adventure Game

## Overview

This document describes the database schema used to store story content, user sessions, and game state for the text adventure game. The schema is designed to support persistent user sessions, multi-story gameplay, and optional user accounts.

## Tables

### `stories`

Stores metadata for different story campaigns.

```sql
CREATE TABLE stories (
  id TEXT PRIMARY KEY,
  title TEXT NOT NULL,
  description TEXT,
  is_active BOOLEAN DEFAULT TRUE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Columns:**
- `id`: Unique identifier for the story (e.g., 'mystical-forest')
- `title`: Display title for the story
- `description`: Brief description of the story
- `is_active`: Whether this story is available for selection
- `created_at`: Timestamp when the story was created
- `updated_at`: Timestamp when the story was last modified

### `story_nodes`

Stores the main story content - individual scenes or nodes in the adventure.

```sql
CREATE TABLE story_nodes (
  id TEXT PRIMARY KEY,
  story_id TEXT NOT NULL REFERENCES stories(id) ON DELETE CASCADE,
  title TEXT NOT NULL,
  text TEXT NOT NULL,
  is_ending BOOLEAN DEFAULT FALSE,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Columns:**
- `id`: Unique identifier for the story node (e.g., 'start', 'door_opened')
- `story_id`: Foreign key to the story this node belongs to
- `title`: Display title for the story scene
- `text`: The main story text/description
- `is_ending`: Whether this node represents an ending to the story
- `created_at`: Timestamp when the node was created
- `updated_at`: Timestamp when the node was last modified

### `choices`

Stores the choices available to players at each story node.

```sql
CREATE TABLE choices (
  id TEXT PRIMARY KEY,
  story_node_id TEXT NOT NULL REFERENCES story_nodes(id) ON DELETE CASCADE,
  text TEXT NOT NULL,
  next_node_id TEXT NOT NULL REFERENCES story_nodes(id),
  order_index INTEGER NOT NULL DEFAULT 0,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Columns:**
- `id`: Unique identifier for the choice
- `story_node_id`: Foreign key to the story node this choice belongs to
- `text`: The choice text displayed to the player
- `next_node_id`: The story node to navigate to when this choice is selected
- `order_index`: Display order for choices (lower numbers appear first)
- `created_at`: Timestamp when the choice was created

### `user_sessions`

Stores user sessions for persistent gameplay across visits.

```sql
CREATE TABLE user_sessions (
  id TEXT PRIMARY KEY,
  user_id TEXT, -- NULL for anonymous sessions
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_accessed TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '30 days')
);
```

**Columns:**
- `id`: Unique session identifier (generated by client)
- `user_id`: Optional foreign key to user account (NULL for anonymous)
- `created_at`: Timestamp when the session was created
- `last_accessed`: Timestamp when the session was last used
- `expires_at`: When the session expires (default: 30 days)

### `game_states`

Stores persistent game progress for each session and story combination.

```sql
CREATE TABLE game_states (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::TEXT,
  session_id TEXT NOT NULL REFERENCES user_sessions(id) ON DELETE CASCADE,
  story_id TEXT NOT NULL REFERENCES stories(id),
  current_node_id TEXT NOT NULL REFERENCES story_nodes(id),
  progress_data JSONB DEFAULT '{}',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Columns:**
- `id`: Unique identifier for the game state
- `session_id`: Foreign key to the user session
- `story_id`: Foreign key to the story being played
- `current_node_id`: The current story node the player is at
- `progress_data`: Additional progress data (choices made, variables, etc.)
- `created_at`: Timestamp when the game state was created
- `updated_at`: Timestamp when the game state was last modified

### `user_accounts` (Optional)

Stores user account information for authenticated users.

```sql
CREATE TABLE user_accounts (
  id TEXT PRIMARY KEY DEFAULT gen_random_uuid()::TEXT,
  email TEXT UNIQUE,
  username TEXT UNIQUE,
  display_name TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);
```

**Columns:**
- `id`: Unique identifier for the user account
- `email`: User's email address (optional, for authentication)
- `username`: User's chosen username (optional)
- `display_name`: User's display name
- `created_at`: Timestamp when the account was created
- `updated_at`: Timestamp when the account was last modified

## Indexes

```sql
-- Performance indexes
CREATE INDEX idx_stories_active ON stories(is_active);
CREATE INDEX idx_story_nodes_id ON story_nodes(id);
CREATE INDEX idx_story_nodes_story_id ON story_nodes(story_id);
CREATE INDEX idx_choices_story_node_id ON choices(story_node_id);
CREATE INDEX idx_choices_order ON choices(story_node_id, order_index);
CREATE INDEX idx_user_sessions_id ON user_sessions(id);
CREATE INDEX idx_user_sessions_user_id ON user_sessions(user_id);
CREATE INDEX idx_user_sessions_expires ON user_sessions(expires_at);
CREATE INDEX idx_game_states_session_id ON game_states(session_id);
CREATE INDEX idx_game_states_story_id ON game_states(story_id);
CREATE INDEX idx_user_accounts_email ON user_accounts(email);
CREATE INDEX idx_user_accounts_username ON user_accounts(username);
```

## Security (Row Level Security)

The schema includes Row Level Security policies for data protection:

```sql
-- Enable RLS on all tables
ALTER TABLE stories ENABLE ROW LEVEL SECURITY;
ALTER TABLE story_nodes ENABLE ROW LEVEL SECURITY;
ALTER TABLE choices ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE game_states ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_accounts ENABLE ROW LEVEL SECURITY;

-- Public read access for story content
CREATE POLICY "Allow public read on stories" ON stories
  FOR SELECT USING (is_active = true);

CREATE POLICY "Allow public read on story_nodes" ON story_nodes
  FOR SELECT USING (true);

CREATE POLICY "Allow public read on choices" ON choices
  FOR SELECT USING (true);

-- User-specific access for sessions and game states
CREATE POLICY "Users can manage their own sessions" ON user_sessions
  FOR ALL USING (true);

CREATE POLICY "Users can manage their own game states" ON game_states
  FOR ALL USING (true);

CREATE POLICY "Users can manage their own accounts" ON user_accounts
  FOR ALL USING (true);
```

## Environment Variables

The application requires these environment variables:

- `NEXT_PUBLIC_SUPABASE_URL`: Your Supabase project URL
- `NEXT_PUBLIC_SUPABASE_ANON_KEY`: Your Supabase anonymous/public key

## Usage

The application uses the `StoryService` class to interact with the database:

```typescript
import { StoryService } from '@/lib/story-service'

// Get all available stories
const stories = await StoryService.getStories()

// Get a random story
const randomStory = await StoryService.getRandomStory()

// Get a story node with its choices
const node = await StoryService.getStoryNode('start', 'mystical-forest')

// Session management
const sessionId = StoryService.getOrCreateSessionId()
const session = await StoryService.createSession(sessionId)

// Game state persistence
const gameState = await StoryService.saveGameState(sessionId, storyId, nodeId)
const savedState = await StoryService.getGameState(sessionId, storyId)

// Health check
const isHealthy = await StoryService.healthCheck()
```

## Features Supported

### Anonymous User Sessions
- Automatic session ID generation and localStorage persistence
- 30-day session expiration
- No authentication required

### Multi-Story Support
- Multiple story campaigns in database
- Random story selection for new games
- Story-specific game state tracking

### Game State Persistence
- Automatic progress saving on each choice
- Resume functionality when returning to the app
- Session-based state management

### Fallback Mode
- Graceful degradation when Supabase is not configured
- Original hardcoded story data as fallback
- Identical user experience in both modes

## Migration from Hardcoded Data

The existing hardcoded story data can be migrated using the provided SQL script. See `scripts/migrate-story-data.sql` for the complete migration.